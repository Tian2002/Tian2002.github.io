<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二分查找法(C语言)</title>
      <link href="/2022/03/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95-C%E8%AF%AD%E8%A8%80/"/>
      <url>/2022/03/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95-C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找法-C语言"><a href="#二分查找法-C语言" class="headerlink" title="二分查找法(C语言)"></a>二分查找法(C语言)</h2><ul><li>前置条件：在一个已经排序的数组中 以一个int型的数组升序排列为例(泛型暂时还不会)</li><li>时间复杂度O(logn)</li></ul><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><ul><li>初始left=0，right=arr.length-1</li><li>mid=l+(r-l)/2而不是mid=(r+l)/2,是为了防止整形溢出</li><li>函数的返回值 若在函数中找到了target，则返回索引值，否则返回-1</li></ul><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><pre class=" language-shell"><code class="language-shell">int search(int *num,int left,int right,int target)&#123;    if(left&gt;right) return -1;    int mid=left+(right-left)/2;    if(num[mid]==target) return mid;    else if(num[mid]&lt;target) return search(num,mid+1,right,target);    return search(num,left,mid-1,target);&#125;</code></pre><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><pre class=" language-shell"><code class="language-shell">int search(int *num,int l,int r,int target)&#123;    while(l&lt;=r)    &#123;        int mid=l+(r-l)/2;        if(num[mid]==target) return mid;        if(num[mid]&lt;target) l=mid+1;        else r=mid-1;    &#125;    return -1;&#125;</code></pre><h3 id="二分查找法的变种"><a href="#二分查找法的变种" class="headerlink" title="二分查找法的变种"></a>二分查找法的变种</h3><h4 id="upper"><a href="#upper" class="headerlink" title="upper"></a>upper</h4><ul><li>寻找大于target的最小值</li><li>函数的返回值 若在函数中找到了目标值，则返回目标值的索引，否则返回arr.length。因为当target&lt;max{arr[i]}时一定可以在数组中找到相应的值，当target&gt;=max{arr[i]}时，数组中不存在满足条件的值，该值应该在arr[arr.length-1]的右侧，故返回arr.length，对于数组arr，arr.length为非法索引</li><li>若有几个相同的目标值，则返回其中最小的索引</li><li>初始l=0,r=arr.length</li><li>注意当arr[mid]==target时边界的变化应该和小于是相同还是大于时相同</li><li>当arr[mid]&gt;target时，边界应当r=mid而不是r=mid-1.因为可能arr[mid]&gt;target,arr[mid-1]&lt;=target<pre class=" language-shell"><code class="language-shell">int search(int *nums,int l,int r,int target) &#123;  if(l==r) return l;  int mid=l+(r-l)/2;  if(nums[mid]&gt;target) return search(nums,l,mid,target);  return search(nums,mid+1,r,target);&#125;</code></pre></li></ul><h4 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h4><ul><li>寻找小于target的最大值</li><li>函数的返回值 若在函数中找到了目标值，则返回目标值的索引，否则返回-1。</li><li>初始时l=-1,r=arr.length-1</li><li>注意lower变种中mid=l+(r-1+1)/2与upper不同，这是因为当mid=l+(r-l)/2在r、l相邻时l==mid，若此时arr[mid]&lt;target会使函数进入死循环<pre class=" language-shell"><code class="language-shell">int search(int *nums, int l, int r, int target)&#123;  if (l == r)      return l;  int mid = l + (r - l + 1)/2;  if (nums[mid] &lt; target)      return search(nums, mid, r, target);   return search(nums, l, mid - 1, target);&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> PracticeNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-数组</title>
      <link href="/2022/03/22/PHP-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/22/PHP-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="PHP数组基础练习记录"><a href="#PHP数组基础练习记录" class="headerlink" title="PHP数组基础练习记录"></a>PHP数组基础练习记录</h3><pre class=" language-shell"><code class="language-shell">&lt;?php//一维数组$arr=array("first"=&gt;"firstelement","第二个"=&gt;"secondelement");//key=&gt;value$arr1=array("UTP-8","GBK");//默认为数字的下标echo('数组的个数是'.sizeof($arr).'&lt;br /&gt;');print_r($arr);//打印数组的所有分量echo'&lt;br /&gt;';echo($arr["first"]);$arr1[3]="test";//添加元素$arr1[]="kukuku";echo'&lt;br /&gt;';print_r($arr1);echo'&lt;br /&gt;';var_dump($arr);echo'&lt;br /&gt;';//二维数组$arr2=array(array("A","B"),array("C","D"));print_r($arr2);echo'&lt;br /&gt;';var_dump($arr2);echo'&lt;br /&gt;';$arr3=array(1,2,3,4,5);//array_unshift();//添加在数组头部array_push($arr3,5);//添加在数组末尾print_r($arr3);echo'&lt;br /&gt;';//array_shift();//删除数组的首个元素array_pop($arr3);//删除数组末尾元素print_r($arr3);echo'&lt;br /&gt;';if(in_array("firstelement",$arr))//检测数组中是否有某个值，返回的是Boolean值&#123;    echo('firstelement在数组arr中');    echo'&lt;br /&gt;';&#125;if(in_array("secondelement",$arr,True))//添加了第三个参数就要求两个值 ===&#123;    echo('secondelement在数组arr中');    echo'&lt;br /&gt;';&#125;$key=array_search("firstelement",$arr);echo($key.'&lt;br /&gt;');//查找数组中是否有该value，如果有就返回该key的位序,没有就返回false，可以添加第三个参数，同in_array()if(array_key_exists("first",$arr))//检测数组中是否有某个key，返回值为Boolean值&#123;    echo('数组arr中有key值first&lt;br /&gt;');&#125;print_r(array_keys($arr));//数组的每一个key值echo'&lt;br&gt;';print_r(array_values($arr));//数组的每一个value值echo'&lt;br /&gt;';echo'&lt;hr /&gt;';//数组的指针$a=count($arr);//获取数组元素的数量echo('数组arr的元素数量为'.$a.'&lt;br /&gt;');$a=current($arr);//获取当前指针下的数组元素echo($a.' ');$a=next($arr);//将数组指针移动到下一个位置echo($a.'&lt;br /&gt;');$a=prev($arr);//将数组指针移到数组第一个元素echo(' '.reset($arr).' ');//reset()同prev()echo($a.' ');$a=end($arr);//将数组指针移到最后一个元素echo($a.'&lt;br /&gt;');//利用current()和next()遍历数组$a=prev($arr);echo($a);for($i=0;$i&lt;sizeof($arr);$i++)&#123;    echo(' '.next($arr));&#125;echo'&lt;br /&gt;';//使用foreach(数组 as $value)遍历数组foreach ($arr as $value)&#123;    echo($value.' ');&#125;echo'&lt;hr /&gt;';$arr4=array(1,2,3,1,'1','2');$arr2=array_unique($arr4);//去掉数组中重复的元素print_r($arr2);//去重是判断是==echo'&lt;br /&gt;';print_r($arr4);//去重后原数组不变echo'&lt;br /&gt;';$arr4=array(3,2,4,1);asort($arr4);//升序排列数组,改变原数组，返回的是布尔值print_r($arr4);arsort($arr4);//降序排列数组,改变原数组echo'&lt;br /&gt;';print_r($arr4);echo'&lt;br /&gt;';$arr3=array_reverse($arr4);//反序排列数组，返回数组，原数组不变print_r($arr3);echo'&lt;br /&gt;';print_r($arr4);echo'&lt;br /&gt;';$arr=array_fill(1,2,'element');//函数可以指定的值填充所有的数组元素,array array_fill ( int $start_index, int $num, mixed $value)print_r($arr);echo'&lt;br /&gt;';$arr4=array_merge($arr1,$arr2);//函数可以将多个数组合并为一个数组。array array_merge ( array array1, array array2 [, array ...])print_r($arr4);echo'&lt;br /&gt;';$arr4=array(1,2,3,4,5,6,4,3123,3,2,3,3,4,1,);$arr1=array_count_values($arr4);//用于统计数组中所有值的个数,返回一个数组print_r($arr1);echo'&lt;br /&gt;';echo(array_sum($arr4).'&lt;hr /&gt;');//求出数组中所有元素的和</code></pre>]]></content>
      
      
      <categories>
          
          <category> PracticeNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-翻转单链表（循环/递归）</title>
      <link href="/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BF%BB%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%BE%AA%E7%8E%AF-%E9%80%92%E5%BD%92%EF%BC%89/"/>
      <url>/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BF%BB%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%BE%AA%E7%8E%AF-%E9%80%92%E5%BD%92%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="翻转单链表-循环法-递归法"><a href="#翻转单链表-循环法-递归法" class="headerlink" title="翻转单链表-循环法/递归法"></a>翻转单链表-循环法/递归法</h3><pre class=" language-shell"><code class="language-shell">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElemType;typedef struct date&#123;    ElemType elem;    struct date *next;&#125; List;List *InitList(List *L) //初始化链表&#123;    ElemType t;    List *p;    L = p = (List *)malloc(sizeof(List));    p->next = NULL;    printf("请输入链表元素,直到输入0截至\n");    scanf("%d", &t);    while (t)    &#123;        p->next = (List *)malloc(sizeof(List));        p = p->next;        p->elem = t;        p->next = NULL;        scanf("%d", &t);    &#125;    return L;&#125;void PrintList(List *L) //输出链表&#123;    List *p = L;    int i = 1;    while (p->next)    &#123;        p = p->next;        printf("%d\t", p->elem);        if (++i % 10 == 0)            printf("\n");    &#125;    printf("\n");&#125;List *FlipList(List *L) //翻转链表 迭代法&#123;    List *newHead = L, *p, *p1, *p2;    p = newHead->next;    newHead->next = NULL;    while (p != NULL)    &#123;        p2 = newHead->next;        newHead->next = p;        p1 = p->next;        p->next = p2;        p = p1;    &#125;    return newHead;&#125;List *FlipList_(List *L) //翻转链表 递归法 递归时需要去头&#123;    if (!L || !L->next) //短路原则        return L;    List *newHead = FlipList_(L->next);    L->next->next = L;    L->next = NULL;    return newHead;&#125;List *FlipList__(List *L) //去头进入递归，然后再加入空的头节点&#123;    List *head = L->next;    head = FlipList_(head);    L->next = head;    return L;&#125;int main()&#123;    int i;    List *L;    L = InitList(L);    PrintList(L);    printf("输入1翻转链表,其他输入退出程序\n");    scanf("%d", &i);    if (i == 1)    &#123;        system("CLS");        // L = FlipList(L);        L = FlipList__(L);        PrintList(L);    &#125;    else        exit(0);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SchoolAssignment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java上机-初识Java</title>
      <link href="/2022/03/18/Java%E4%B8%8A%E6%9C%BA-%E5%88%9D%E8%AF%86Java/"/>
      <url>/2022/03/18/Java%E4%B8%8A%E6%9C%BA-%E5%88%9D%E8%AF%86Java/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><pre class=" language-shell"><code class="language-shell">public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println("Hello,World!");    &#125;&#125;</code></pre><h3 id="Hello-Date"><a href="#Hello-Date" class="headerlink" title="Hello Date"></a>Hello Date</h3><pre class=" language-shell"><code class="language-shell">import java.util.*;public class HelloDate &#123;    public static void main(String[] args) &#123;        System.out.println("Hello,it's ");        System.out.println(new Date());    &#125;&#125;</code></pre><h3 id="String-args参数的输入的引用"><a href="#String-args参数的输入的引用" class="headerlink" title="String[] args参数的输入的引用"></a>String[] args参数的输入的引用</h3><pre class=" language-shell"><code class="language-shell">public class Hello &#123;    public static void main(String[] args) &#123;        System.out.println("Hello,args[0] is "+args[0]);    &#125;&#125;</code></pre><h3 id="SkyAndStars"><a href="#SkyAndStars" class="headerlink" title="SkyAndStars"></a>SkyAndStars</h3><pre class=" language-shell"><code class="language-shell">import java.awt.*;public class SkyAndStars &#123;    public static void main(String[] args) &#123;        Frame w = new Frame() ;        w.setSize(1024 , 768) ;        w.setBackground(Color.BLACK) ;        MyPanel mp = new MyPanel() ;        w.add(mp) ;        w.setVisible(true) ;    &#125;&#125;class MyPanel extends Panel &#123;    public void paint(Graphics g) &#123;        g.setColor(Color.WHITE) ;        for (int i = 0; i < 300; i++) &#123;        g.drawString("*",(int)(Math.random()*1024),    (int)(Math.random()*768)) ;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SchoolAssignment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构作业-线性表的顺序表示和链式表示</title>
      <link href="/2022/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA/"/>
      <url>/2022/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>为了实现顺序表和链表的建立、取元素、修改元素、插入、删除等顺序表的基本操作。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-shell"><code class="language-shell">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_LENGTH 100 //规定线性表的最大长度#define ERROR -1#define OVERFLOW -2#define OK 1typedef int Status;typedef int ElemType; //为了方便，将元素的类型设置为int型typedef struct&#123;    ElemType elem[MAX_LENGTH];    int length;&#125; List;typedef struct List__Elem&#123;    ElemType _elem;    struct List_Elem *next;&#125; elem_;//顺序表和链式表的创建Status CreateList(List **L, elem_ **L1)&#123;    int n, i;    elem_ *p;    *L = (List *)malloc(sizeof(List));    p = (*L1) = (elem_ *)malloc(sizeof(elem_)); //第一个节点为空，这里顺便可以用第一个节点的elem记录元素个数    if (!*L || !p)        exit(0);    (*L)->length = 0;    printf("请输入数据的个数\n");    scanf("%d", &n);    (*L)->length = n;    p->_elem = n;    printf("请输入数据，数据间用空格隔开，输入完成后，请输入回车\n");    for (i = 0; i < n; i++)    &#123;        scanf("%d", &((*L)->elem[i]));        p->next = (elem_ *)malloc(sizeof(elem_));        p = p->next; // vs code不允许p->next->next        p->_elem = (*L)->elem[i];    &#125;    p->next = NULL;    return OK;&#125;//顺序表和链式表的插入Status InsertList(List *L, elem_ *L1, int i, ElemType e)&#123;    if (i > MAX_LENGTH)    &#123;        printf("插入的位置超出最大长度\n");        return ERROR;    &#125;    if (L->length == MAX_LENGTH)    &#123;        printf("该链表已满，无法插入\n");        return OVERFLOW;    &#125;    int k;    elem_ *p, *p1, *p2;    for (k = L->length; k >= i; k--)    &#123;        L->elem[k] = L->elem[k - 1];    &#125;    L->elem[i - 1] = e;    p = L1;    for (k = 1; k < i; k++)    &#123;        p = p->next;    &#125;    p1 = p->next;    p->next = (elem_ *)malloc(sizeof(elem_));    p2 = p->next;    p2->_elem = e;    p2->next = p1;    L->length++;    L1->_elem++;    return OK;&#125;//顺序表和链式表的删除Status DeleteElem(List *L, elem_ *L1, int i)&#123;    if (i > MAX_LENGTH)    &#123;        printf("删除的位置超出最大长度\n");        return ERROR;    &#125;    int k;    elem_ *p = L1, *p1;    for (k = i; k < L->length; k++)    &#123;        L->elem[k - 1] = L->elem[k];    &#125;    for (k = 1; k < i; k++)    &#123;        p = p->next;    &#125;    p1 = p->next;    if (p1)    &#123;        p->next = p1->next;        free(p1);    &#125;    L1->_elem--;    L->length--;    return OK;&#125;//长度int LengthList(List *L)&#123;    printf("该线性表的长度为%d\n", L->length);    return L->length;&#125;//顺序表的显示输出void PrintList(List *L)&#123;    int i, k;    for (i = 0, k = 1; i < L->length; i++)    &#123;        printf("%d\t", L->elem[i]);        if (++k % 10 == 0)            printf("\n");    &#125;    printf("\n");&#125;//取链表的第i个元素Status GetElem(elem_ *L, int i)&#123;    int k;    elem_ *p = L;    for (k = 0; k < i; k++)    &#123;        p = p->next;    &#125;    printf("链表的第%d个元素为%d\n", i, p->_elem);&#125;//链表的输出void PrintList_(elem_ *L)&#123;    int i = 1;    elem_ *p = L;    while (p->next)    &#123;        p = p->next;        printf("链表中第%d个元素的值为%d 地址为%p\n", i, p->_elem, p);        i++;    &#125;&#125;// //对key的判断void KeyJudge(int key, List *L, elem_ *L1)&#123;    void Menu(void);    int i;    ElemType e;    switch (key)    &#123;    case 1:        // int i;        // ElemType e;        printf("请输入需要插入的元素\n");        scanf("%d", &e);        printf("请输入需要插入元素的位置\n");        scanf("%d", &i);        system("CLS");        InsertList(L, L1, i, e);        Menu();        break;    case 2:        // int i;        printf("请输入你需要删除元素的位序\n");        scanf("%d", &i);        system("CLS");        DeleteElem(L, L1, i);        Menu();        break;    case 3:        system("CLS");        LengthList(L);        Menu();        break;    case 4:        system("CLS");        PrintList(L);        Menu();        break;    case 5:        printf("请输入需要插入的元素\n");        scanf("%d", &e);        printf("请输入需要插入元素的位置\n");        scanf("%d", &i);        system("CLS");        InsertList(L, L1, i, e);        Menu();        break;    case 6:        printf("请输入你需要删除元素的位序\n");        scanf("%d", &i);        system("CLS");        DeleteElem(L, L1, i);        Menu();        break;    case 7:        printf("请输入你所取元素的位置\n");        scanf("%d", &i);        system("CLS");        GetElem(L1, i);        Menu();        break;    case 8:        system("CLS");        PrintList_(L1);        Menu();        break;    case 9:        exit(0);        break;    default:        system("CLS");        printf("输入错误，请重新输入\n");        Menu();    &#125;&#125;int main()&#123;    void Menu(void); //显示菜单    int key;    List *L1, *L2;    printf("输入1进入程序\n");    printf("输入2退出程序\n");    scanf("%d", &key);    if (key == 1)    &#123;        CreateList(&L1, &L2);        Menu();        for (;;) //一个死循环，直到key==9时exit(0)        &#123;            scanf("%d", &key);            KeyJudge(key, L1, L2);        &#125;    &#125;    else if (key == 2)        exit(0);    else        printf("输入错误，请重新输入");    return 0;&#125;//显示菜单void Menu(void)&#123;    printf("1:顺序表的插入\n2:顺序表的删除\n3:顺序表的长度\n4:顺序表的显示输出\n5:链表的插入\n6:链表的删除\n7:取链表的第i个元素\n8:链表的输出\n9:退出程序\n请选择1—9:\n");&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SchoolAssignment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/16/hello-world/"/>
      <url>/2022/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
